import { Meta, Canvas } from "@storybook/addon-docs/blocks";

<Meta title="React/Developing/Conventions" />

# Conventions

There are some some common conventions and presiding principles with which this library has been constructed.

## Code style

The library uses Prettier code styling for simplicity. Nothing else to report here.

## Naming things

When it comes to naming conventions, there are two primary driving motivations behind all naming choices:

-   Readability/Reason-Ability
-   Explicitness/Specificity

### Readability / Reason-Ability / Explicitness

Ideally, developers should be able to immediately look at a prop and understand what it is for without reading the docs. Prop names should immediately denote what they are for and set out to do. Favor verbosity (within reason). We want to make our code easy to reason about.

Most of the issues that we are attempting to alleviate with these conventions are safeguarded against simply by using `prop-types`. Even though `prop-types` are used on **every React component** in this library, we still strive for these patterns because they aid in consistency and an improved developer experience.

Here are some general guidelines when naming props:

**DO NOT ðŸš«**

```js
// Context of this is ambiguous, make sure this is not an action/event/callback
update;
```

**DO NOT ðŸš«**

```js
// While more specific and denotes an action, we want to favor using the `on` convention
// to denote that this is something that happens when a person is updated
updatePerson = () => {};
```

**DO âœ…**

```js
// prefixing event/actionable things with "on" will help the next user understand
// immediately that is prop should expect something to happen when something updates.
onUpdate;
```

**DO âœ…**

```js
// if current use case has more than one context, specify the context (least specific -> more specific)
onUpdatePerson;
```

**DO NOT ðŸš«**

```js
// As a boolean, usage of "is" is debatable here, with this library we have chosent to use is/has for all boolean
// Note: This is enforced by ESLINT
loading;
```

**DO âœ…**

```js
isLoading; // prefixing boolean props with "is" can help immediately infer that this should expect a boolean.
```

**DO NOT ðŸš«**

```js
person; // this prop might be expecting an object, if a name or id is expected, specify that explicitly (see next section)
```

**DO âœ…**

```js
personId; // if this prop expects an "id", name it as such. (Note: we use camelCase, unless a class or component name)
```

**DO NOT ðŸš«**

```js
person = "Bob";
// without knowing assignment, the prop here doesn't tell us that it should be a string, the prop could be expected to receive an object
```

> ! This applies to file names as well. Structuring files this way will keep them organized and ordered by file systems.

**DO âœ…**

```js
personName = "Bob"; // Obviously a name should be expected
```

### Specificity

Ordering specificity

**DO NOT ðŸš«**

```css
/* specificity is jumping back and forth; broadest / specific / middle */
.mainsail-light-blue {
}
.mainsail-medium-blue {
}
.mainsail-dark-blue {
}
```

**DO âœ…**

```css
/* choose to describe in order from least to most specific; broadest (namespace) / middle / specific */
.mainsail-blue-light {
}
.mainsail-blue-medium {
}
.mainsail-blue-dark {
}

/*
This specificity ordering convention makes more sense in the context of a group of named items.
By itself `mainsail-light-blue` doesn't seem too egregious. If combined with others of similar nomenclature,
coding/sorting benefits emerge by inverting theses specificity values.
*/
```

### Enumerable Props

The decision has been made to provide a convention to mitigate [magic string](https://softwareengineering.stackexchange.com/questions/365339/what-is-wrong-with-magic-strings) usage in/for this library.

Props that are utilized in a component should have their ENUM values exposed and exported as such.

For Example:

```js
// The Button Component has a `variant` prop.

<Button variant="primary" />

// Vs

<Button variant={variants.primary} />
```

Usage of the prop could be handled by passing a string of "primary" but it is actually better to provide a means for the end-user-developer to not have to use strings at all for their prop if we can.

"But why?" You might ask.

Magic strings are prone to causing bugs. These bugs are likely to only surface at runtime. Here's some quick benefits

-   If you type a string wrong, you likely won't discover it until the component renders and maybe not until it hits production
-   Autocomplete in most editors is provided by supplying enums/objects
-   Find/Replace becomes easier when not using strings
-   Developer friendliness increases as you need to consult the docs less

Setup may look like this:

```js
// Button.js
...

export const variants = {
    primary: "primary",
    secondary: "secondary",
    tertiary: "tertiary",
    link: "link",
    icon: "icon",
};

...

// Component code below
```

Usage may look like this:

```js
// Button.stories.js
import { Button, variants } from "./Button";

export const Primary = Template.bind({});
Primary.args = {
    variant: variants.primary,
    text: "Click me",
};
```
