(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7366],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||r;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5341:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return m}});var a=n(2122),i=n(9756),r=(n(7294),n(3905)),o=["components"],s={sidebar_position:2,title:"Style Guide"},l="Style Guide & Principles",p={unversionedId:"development/style-guide",id:"development/style-guide",isDocsHomePage:!1,title:"Style Guide",description:"There are some common conventions and presiding principles with which this library has been constructed.",source:"@site/docs/development/style-guide.md",sourceDirName:"development",slug:"/development/style-guide",permalink:"/docs/development/style-guide",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/development/style-guide.md",version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Style Guide"},sidebar:"tutorialSidebar",previous:{title:"Editor Config",permalink:"/docs/development/editor-config"},next:{title:"Building Components",permalink:"/docs/development/building-components"}},u=[{value:"Code Style",id:"code-style",children:[]},{value:"Naming Things",id:"naming-things",children:[]},{value:"Readability / Reason-Ability / Explicitness with Props",id:"readability--reason-ability--explicitness-with-props",children:[]},{value:"Example Guidelines when Naming Props",id:"example-guidelines-when-naming-props",children:[]},{value:"Specificity",id:"specificity",children:[]},{value:"Imports",id:"imports",children:[]},{value:"Enumerable Props",id:"enumerable-props",children:[]},{value:"Exports Concepts",id:"exports-concepts",children:[]}],c={toc:u};function m(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"style-guide--principles"},"Style Guide & Principles"),(0,r.kt)("p",null,"There are some common conventions and presiding principles with which this library has been constructed."),(0,r.kt)("h2",{id:"code-style"},"Code Style"),(0,r.kt)("p",null,"The library uses Prettier code styling for simplicity. Nothing else to report here."),(0,r.kt)("h2",{id:"naming-things"},"Naming Things"),(0,r.kt)("p",null,"When it comes to naming conventions, there are a some primary driving motivations behind all naming choices:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Readability")," - keep it readable"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Reason-Ability")," - keep it able to be immediately able to be reasoned with"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Explicitness")," - leave nothing ambiguous, #futureMeIsDumb"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Specificity")," - ordering of context can create clearer code")),(0,r.kt)("h2",{id:"readability--reason-ability--explicitness-with-props"},"Readability / Reason-Ability / Explicitness with Props"),(0,r.kt)("p",null,"Ideally, developers should be able to immediately look at a component prop and understand what it is for without reading the docs."),(0,r.kt)("p",null,"Prop names should immediately denote what they are used for and set out to do. Favor verbosity (within reason). We want to make our code easy to reason about."),(0,r.kt)("p",null,"Most of the issues that we are attempting to alleviate with these conventions are safeguarded against simply by using ",(0,r.kt)("inlineCode",{parentName:"p"},"prop-types")," and a little help from ESLINT."),(0,r.kt)("p",null,"Even though ",(0,r.kt)("inlineCode",{parentName:"p"},"prop-types")," are used on ",(0,r.kt)("strong",{parentName:"p"},"every React component")," in this library, we still strive for these patterns because they aid in consistency and an improved developer experience."),(0,r.kt)("p",null,"Many editors benefit from including prop-types."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/30707961/114555435-b04d7c80-9c35-11eb-844e-ab7cb40fdeaf.gif",alt:"VS Code auto completion"})),(0,r.kt)("h2",{id:"example-guidelines-when-naming-props"},"Example Guidelines when Naming Props"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO NOT \ud83d\udeab")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Context of this verb is ambiguous, is this is not an action/event/callback?\nupdate;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO NOT \ud83d\udeab")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// While more specific and denotes an action, we want to favor using the `on` convention\n// to denote that this is something that happens when a person is updated\nupdatePerson = () => {};\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO \u2705")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// prefixing event/actionable things with "on" will help the next user understand\n// immediately that is prop should expect something to happen when something updates.\nonUpdate;\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO \u2705")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// if current use case has more than one context, specify the context (least specific -> more specific)\nonUpdatePerson;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO NOT \ud83d\udeab")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// As a boolean, usage of "is" is debatable here, with this library we have chosent to use is/has for all boolean\n// Note: This is enforced by ESLINT\nloading;\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO \u2705")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// prefixing boolean props with "is/has/should" can help immediately infer that this should expect a boolean.\nisLoading;\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO NOT \ud83d\udeab")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// this prop might be expecting an object, if a name or id is expected, specify that explicitly (see next section)\nperson;\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO \u2705")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// if this prop expects an "id", name it as such. (Note: we use camelCase, unless a class or component name where PascalCase is used)\npersonId;\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO NOT \ud83d\udeab")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// without knowing assignment, the prop here doesn\'t tell us that it should be a string, the prop could be expected to receive an object\nperson = "Bob";\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO \u2705")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'personName = "Bob"; // Obviously a name should be expected\n')),(0,r.kt)("h2",{id:"specificity"},"Specificity"),(0,r.kt)("p",null,"Ordering specificity by context"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO NOT \ud83d\udeab")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"/* specificity is jumping back and forth; broadest / specific / middle */\n.mainsail-light-blue {\n}\n.mainsail-medium-blue {\n}\n.mainsail-dark-blue {\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO \u2705")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-css"},"/* choose to describe in order from least to most specific; broadest (namespace) / middle / specific */\n.mainsail-blue-light {\n}\n.mainsail-blue-medium {\n}\n.mainsail-blue-dark {\n}\n\n/*\nThis specificity ordering convention makes more sense in the context of a group of named items.\nBy itself `mainsail-light-blue` doesn't seem too egregious. If combined with others of similar nomenclature,\ncoding/sorting benefits emerge by inverting theses specificity values to `mainsail-blue-light`.\n*/\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\ud83d\udcc2 This applies to file names as well. Structuring files this way will keep them organized and ordered by file systems.")),(0,r.kt)("h2",{id:"imports"},"Imports"),(0,r.kt)("p",null,"Regarding importing, the ",(0,r.kt)("inlineCode",{parentName:"p"},"mainsail-ui")," developer environment supports a few convenient absolute alias resolvers (set up in ",(0,r.kt)("inlineCode",{parentName:"p"},"jsconfig.json"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},".storybook/main.js")," for editors, jest, and storybook respectively)."),(0,r.kt)("p",null,"The following paths are aliased:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"components"),(0,r.kt)("li",{parentName:"ul"},"styles"),(0,r.kt)("li",{parentName:"ul"},"utility")),(0,r.kt)("p",null,"These folders are resolved for you so you don't need to use relative paths that leave you scratching your head wondering how deep something should be in a folder import."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO NOT \ud83d\udeab")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Button.stories.js uses icon component\nimport { Icon } from "../Icon";\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"DO \u2705")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Use the absolute alias instead\nimport { Icon } from "components/Icon";\n')),(0,r.kt)("p",null,"This results in clearer, more readable imports."),(0,r.kt)("p",null,"\ud83d\udca1 ",(0,r.kt)("strong",{parentName:"p"},"As a rule of thumb, if you have more than one dot in the path, try to make it absolute with an included alias.")),(0,r.kt)("h2",{id:"enumerable-props"},"Enumerable Props"),(0,r.kt)("p",null,"The decision has been made to provide a convention to mitigate ",(0,r.kt)("a",{parentName:"p",href:"https://softwareengineering.stackexchange.com/questions/365339/what-is-wrong-with-magic-strings"},"magic string")," usage in/for this library."),(0,r.kt)("p",null,"Props with enum type of values that are utilized in a component should have their values exposed and exported as such. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/development/building-components"},"Building a Component")," for more details."),(0,r.kt)("p",null,"For Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Okay: The Button Component has a `variant` prop.\n\n<Button variant="primary" />\n\n// Better\n\n<Button variant={Button.variants.primary} />\n')),(0,r.kt)("p",null,'Usage of the prop could be handled by passing a string of "primary" but it is actually better to provide a means for the end-user-developer to not have to use strings at all for their prop if we can.'),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},'"But why?"')," You might ask."),(0,r.kt)("p",null,"Magic strings are prone to causing bugs. These bugs are likely to only surface at runtime. Here's some quick benefits"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If you type a string wrong, you likely won't discover it until the component renders and maybe not until it hits production"),(0,r.kt)("li",{parentName:"ul"},"Autocomplete in most editors is provided by supplying enums/objects"),(0,r.kt)("li",{parentName:"ul"},"Find/Replace becomes easier/more accurate when not using strings"),(0,r.kt)("li",{parentName:"ul"},"Developer friendliness increases as you need to consult the docs less with prop key/values")),(0,r.kt)("p",null,"Setup may look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Button.js\n...\nexport const variants = {\n        primary: "primary",\n        secondary: "secondary",\n        tertiary: "tertiary",\n        link: "link",\n        icon: "icon",\n    }\n\n// The global export is being deprecated in favor of Component-specific prop name attaching\nexport const ENUMS = {\n    variants\n};\n\n...\n\n// Button Component code\n...\n\n// Attached prop values\nButton.variants = variants\n\n')),(0,r.kt)("p",null,"Usage may look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Button.stories.js\nimport { Button } from "./Button";\n\nexport const Primary = Template.bind({});\nPrimary.args = {\n    variant: Button.variants.primary,\n    text: "Click me",\n};\n')),(0,r.kt)("h2",{id:"exports-concepts"},"Exports Concepts"),(0,r.kt)("p",null,"Individual component directories are exported with an ",(0,r.kt)("inlineCode",{parentName:"p"},"index.js")," file solely for cleaner imports within this project."),(0,r.kt)("p",null,"Also, there are some plop-driven export bits of logic that aid in the building of the libary for distribution."))}m.isMDXComponent=!0}}]);